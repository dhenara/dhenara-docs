"use strict";(self.webpackChunkdhenara_docs=self.webpackChunkdhenara_docs||[]).push([[6072],{8048:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"dhenara-agent/concepts/event-system","title":"Event System","description":"Overview","source":"@site/docs/dhenara-agent/concepts/event-system.md","sourceDirName":"dhenara-agent/concepts","slug":"/dhenara-agent/concepts/event-system","permalink":"/dhenara-agent/concepts/event-system","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Event System"},"sidebar":"dhenaraAgentSidebar","previous":{"title":"Run System","permalink":"/dhenara-agent/concepts/run-system"},"next":{"title":"Input Handling","permalink":"/dhenara-agent/concepts/input-handling"}}');var s=t(4848),o=t(8453);const r={title:"Event System"},a="Event System",d={},l=[{value:"Overview",id:"overview",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Event Types",id:"event-types",level:2},{value:"Event Structure",id:"event-structure",level:2},{value:"Common Event Patterns",id:"common-event-patterns",level:2},{value:"Input Handling with node_input_required",id:"input-handling-with-node_input_required",level:3},{value:"Using the Event Bus",id:"using-the-event-bus",level:2},{value:"Registering Handlers",id:"registering-handlers",level:3},{value:"Publishing Events",id:"publishing-events",level:3},{value:"Event Handling Patterns",id:"event-handling-patterns",level:2},{value:"Sequential Handling",id:"sequential-handling",level:3},{value:"Cancellation",id:"cancellation",level:3},{value:"Waiting for Events",id:"waiting-for-events",level:3},{value:"Node Events",id:"node-events",level:2},{value:"Event Handling in the Run Context",id:"event-handling-in-the-run-context",level:2},{value:"Custom Event Definitions",id:"custom-event-definitions",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"event-system",children:"Event System"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"The Event System in Dhenara Agent DSL (DAD) provides a robust mechanism for communication between components. It enables\nloose coupling, dynamic interactions, and event-driven programming patterns within your agent workflows."}),"\n",(0,s.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsx)(n.p,{children:"The event system is built around several key concepts:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Events"}),": Typed messages that carry information about occurrences in the system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Bus"}),": Central mechanism for publishing events and routing them to handlers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Handlers"}),": Functions that respond to specific types of events"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Types"}),": Categorization of events for proper routing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Propagation"}),": Control over how events flow through the component hierarchy"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"event-types",children:"Event Types"}),"\n",(0,s.jsx)(n.p,{children:"DAD defines several standard event types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class EventType:\n    # Standard event types\n    node_input_required = "node_input_required"  # Node needs input before execution\n    node_execution_started = "node_execution_started"  # Node has started execution\n    node_execution_completed = "node_execution_completed"  # Node execution completed\n    node_execution_failed = "node_execution_failed"  # Node execution failed\n    component_execution_started = "component_execution_started"  # Component started\n    component_execution_completed = "component_execution_completed"  # Component completed\n    component_execution_failed = "component_execution_failed"  # Component failed\n    # ... and more\n'})}),"\n",(0,s.jsx)(n.p,{children:"You can also define custom event types for specific application needs."}),"\n",(0,s.jsx)(n.h2,{id:"event-structure",children:"Event Structure"}),"\n",(0,s.jsxs)(n.p,{children:["Events are represented by class instances derived from ",(0,s.jsx)(n.code,{children:"BaseEvent"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"class BaseEvent:\n    event_type: str  # Type identifier for the event\n    # Additional properties depending on event type\n\nclass NodeInputRequiredEvent(BaseEvent):\n    event_type: str = EventType.node_input_required\n    node_id: str  # ID of the node requesting input\n    node_type: str  # Type of the node\n    execution_context: ExecutionContext  # Current execution context\n    input: NodeInput | None = None  # Input to be provided by handler\n    handled: bool = False  # Whether the event has been handled\n"})}),"\n",(0,s.jsx)(n.h2,{id:"common-event-patterns",children:"Common Event Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"input-handling-with-node_input_required",children:"Input Handling with node_input_required"}),"\n",(0,s.jsxs)(n.p,{children:["One of the most common patterns is using the ",(0,s.jsx)(n.code,{children:"node_input_required"})," event to gather inputs for nodes before execution.\nThis enables interactive and dynamic workflows:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Define a node that requires input\nimplementation_flow.node(\n    "code_generator",\n    AIModelNode(\n        pre_events=[EventType.node_input_required],  # Request input before execution\n        settings=AIModelNodeSettings(...),\n    ),\n)\n\n# Handle the input required event\nasync def node_input_event_handler(event: NodeInputRequiredEvent):\n    if event.node_type == FlowNodeTypeEnum.ai_model_call and event.node_id == "code_generator":\n        # Get input from built-in helper\n        node_input = await get_ai_model_node_input(\n            node_def_settings=event.node_def_settings,\n        )\n\n        # Customize with additional inputs if needed\n        task_description = await async_input("Enter your query: ")\n        node_input.prompt_variables = {"task_description": task_description}\n\n        # Provide the input back to the event\n        event.input = node_input\n        event.handled = True\n\n# Register the handler with the run context\nrun_context.register_event_handlers(\n    handlers_map={\n        EventType.node_input_required: node_input_event_handler,\n    }\n)\n'})}),"\n",(0,s.jsx)(n.p,{children:"This pattern allows you to build interactive agents that can prompt for information at runtime rather than having all\ninputs predefined."}),"\n",(0,s.jsx)(n.h2,{id:"using-the-event-bus",children:"Using the Event Bus"}),"\n",(0,s.jsx)(n.h3,{id:"registering-handlers",children:"Registering Handlers"}),"\n",(0,s.jsx)(n.p,{children:"Handlers can be registered to respond to specific event types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from dhenara.agent.dsl.events import EventType\n\n# Define a handler for node input required events\nasync def input_handler(event: NodeInputRequiredEvent):\n    if event.node_id == "my_node":\n        # Provide input for the node\n        event.input = MyNodeInput(param="value")\n        event.handled = True\n\n# Register the handler with the event bus\nevent_bus.register(EventType.node_input_required, input_handler)\n\n# Register a wildcard handler for all events\nasync def logging_handler(event: BaseEvent):\n    print(f"Event received: {event.event_type}")\n\nevent_bus.register_wildcard(logging_handler)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"publishing-events",children:"Publishing Events"}),"\n",(0,s.jsx)(n.p,{children:"Components can publish events to the event bus:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from dhenara.agent.dsl.events import BaseEvent\n\n# Create a custom event\nclass MyCustomEvent(BaseEvent):\n    event_type: str = "my_custom_event"\n    data: dict\n\n# Publish the event\nevent = MyCustomEvent(data={"key": "value"})\nawait event_bus.publish(event)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"event-handling-patterns",children:"Event Handling Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"sequential-handling",children:"Sequential Handling"}),"\n",(0,s.jsx)(n.p,{children:"By default, events are processed sequentially by each registered handler:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'async def handler1(event):\n    print("Handler 1 processing event")\n    # Process event\n\nasync def handler2(event):\n    print("Handler 2 processing event")\n    # Process event\n\nevent_bus.register("my_event_type", handler1)\nevent_bus.register("my_event_type", handler2)\n'})}),"\n",(0,s.jsxs)(n.p,{children:["When a ",(0,s.jsx)(n.code,{children:"my_event_type"})," event is published, both handlers will process it in registration order."]}),"\n",(0,s.jsx)(n.h3,{id:"cancellation",children:"Cancellation"}),"\n",(0,s.jsx)(n.p,{children:"Some events can be canceled by setting a flag in the event:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'async def cancellation_handler(event: CancellableEvent):\n    if should_cancel(event):\n        event.cancelled = True\n        print("Event cancelled")\n\nevent_bus.register("cancellable_event", cancellation_handler)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"waiting-for-events",children:"Waiting for Events"}),"\n",(0,s.jsx)(n.p,{children:"You can wait for specific events to occur:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Create a future to resolve when the event occurs\ncompletion_future = asyncio.Future()\n\nasync def completion_handler(event: ComponentExecutionCompletedEvent):\n    if event.component_id == "target_component":\n        completion_future.set_result(event)\n\nevent_bus.register(EventType.component_execution_completed, completion_handler)\n\n# Wait for the event\ntry:\n    event = await asyncio.wait_for(completion_future, timeout=30.0)\n    print(f"Component completed with status: {event.status}")\nexcept asyncio.TimeoutError:\n    print("Timed out waiting for component completion")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"node-events",children:"Node Events"}),"\n",(0,s.jsx)(n.p,{children:"Nodes can specify events they want to receive or emit:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Node that requires input before execution\nai_node = AIModelNode(\n    pre_events=[EventType.node_input_required],  # Events before execution\n    post_events=[EventType.custom_completion_notification],  # Events after execution\n    resources=ResourceConfigItem.with_model("claude-3-7-sonnet"),\n    settings=AIModelNodeSettings(...),\n)\n'})}),"\n",(0,s.jsx)(n.p,{children:"The node executor will automatically emit the specified pre-events before execution and post-events after execution."}),"\n",(0,s.jsx)(n.h2,{id:"event-handling-in-the-run-context",children:"Event Handling in the Run Context"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"RunContext"})," provides a simplified interface for registering common event handlers:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Create a run context\nrun_context = RunContext(\n    root_component_id="autocoder_root",\n    project_root=project_root,\n)\n\n# Register an input handler in the run context\nasync def my_input_handler(event: NodeInputRequiredEvent):\n    # Handle node input requirements\n    ...\n\n# Register the handler in the run context\nrun_context.register_event_handlers(\n    handlers_map={\n        EventType.node_input_required: my_input_handler,\n        EventType.node_execution_completed: print_node_completion,\n        EventType.component_execution_completed: print_component_completion,\n    }\n)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"custom-event-definitions",children:"Custom Event Definitions"}),"\n",(0,s.jsx)(n.p,{children:"You can define custom events for your specific application needs:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from dhenara.agent.dsl.events import BaseEvent\nfrom pydantic import BaseModel\n\n# Define a custom event type\nMY_CUSTOM_EVENT = "my_app.custom_event"\n\n# Define custom event data model\nclass CustomEventData(BaseModel):\n    user_id: str\n    action: str\n    timestamp: datetime\n\n# Define the custom event class\nclass CustomAppEvent(BaseEvent):\n    event_type: str = MY_CUSTOM_EVENT\n    data: CustomEventData\n\n# Create and publish a custom event\nevent = CustomAppEvent(\n    data=CustomEventData(\n        user_id="user123",\n        action="login",\n        timestamp=datetime.now()\n    )\n)\nawait event_bus.publish(event)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event Type Specificity"}),": Use specific event types for better routing and clarity"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Loose Coupling"}),": Use events to maintain loose coupling between components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handler Focus"}),": Keep event handlers focused on a single responsibility"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": Implement proper error handling in event handlers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debugging"}),": Use the observability system to trace event flow"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Consider performance implications of slow event handlers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consistent Handling Pattern"}),": Follow a consistent pattern for handling events across your application"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Management"}),": Use events for state transitions rather than direct state manipulation"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"The Event System in DAD provides a powerful mechanism for component communication and coordination. By leveraging the\nevent-driven architecture, you can create flexible, loosely coupled agents that can adapt to dynamic requirements and\nrespond to various stimuli during execution. The event system is particularly valuable for creating interactive agents\nthat can request and process user input during runtime."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>a});var i=t(6540);const s={},o=i.createContext(s);function r(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);