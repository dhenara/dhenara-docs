"use strict";(self.webpackChunkdhenara_docs=self.webpackChunkdhenara_docs||[]).push([[550],{5106:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>c,default:()=>x,frontMatter:()=>r,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"dhenara-agent/concepts/execution-context","title":"Execution Context","description":"Overview","source":"@site/docs/dhenara-agent/concepts/execution-context.md","sourceDirName":"dhenara-agent/concepts","slug":"/dhenara-agent/concepts/execution-context","permalink":"/dhenara-agent/concepts/execution-context","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Execution Context"},"sidebar":"dhenaraAgentSidebar","previous":{"title":"Loops and Conditions","permalink":"/dhenara-agent/concepts/flow-control"},"next":{"title":"Observability","permalink":"/dhenara-agent/concepts/observability"}}');var i=t(4848),s=t(8453);const r={title:"Execution Context"},c="Execution Context",a={},l=[{value:"Overview",id:"overview",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Execution Context Hierarchy",id:"execution-context-hierarchy",level:2},{value:"ExecutionContext Class",id:"executioncontext-class",level:2},{value:"Key Properties",id:"key-properties",level:3},{value:"Component Communication through Execution Context",id:"component-communication-through-execution-context",level:2},{value:"Data Access",id:"data-access",level:2},{value:"Component Variables",id:"component-variables",level:2},{value:"Hierarchical References",id:"hierarchical-references",level:2},{value:"Template Expressions",id:"template-expressions",level:2},{value:"Result Management",id:"result-management",level:2},{value:"Integration with Template Engine",id:"integration-with-template-engine",level:2},{value:"Creating and Using Execution Contexts",id:"creating-and-using-execution-contexts",level:2},{value:"Practical Example",id:"practical-example",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"execution-context",children:"Execution Context"})}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The Execution Context in Dhenara Agent DSL (DAD) is a crucial component that manages state, scoping, and data flow\nduring the execution of agents, flows, and nodes. It serves as a central mechanism for communication between components\nand provides access to resources, artifact management, and hierarchical data structures."}),"\n",(0,i.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,i.jsx)(n.p,{children:"The Execution Context system revolves around these key concepts:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"State Management"}),": Tracking execution state (pending, running, completed, failed)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Result Storage"}),": Storing and retrieving the outputs of executed nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Hierarchical Structure"}),": Maintaining parent-child relationships between contexts"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Variable Scoping"}),": Managing variable access across different execution scopes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Resource Access"}),": Providing access to configured resources like AI models"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Component Communication"}),": Enabling data flow between different components through references"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"execution-context-hierarchy",children:"Execution Context Hierarchy"}),"\n",(0,i.jsx)(n.p,{children:"Context objects form a hierarchy that mirrors the component hierarchy:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"AgentExecutionContext\n \u251c\u2500\u2500 FlowExecutionContext 1\n \u2502    \u251c\u2500\u2500 NodeExecutionContext A\n \u2502    \u251c\u2500\u2500 NodeExecutionContext B\n \u2502    \u2514\u2500\u2500 SubflowExecutionContext\n \u2502         \u251c\u2500\u2500 NodeExecutionContext C\n \u2502         \u2514\u2500\u2500 NodeExecutionContext D\n \u251c\u2500\u2500 FlowExecutionContext 2\n \u2502    \u251c\u2500\u2500 NodeExecutionContext E\n \u2502    \u2514\u2500\u2500 NodeExecutionContext F\n \u2514\u2500\u2500 SubagentExecutionContext\n      \u2514\u2500\u2500 FlowExecutionContext 3\n           \u251c\u2500\u2500 NodeExecutionContext G\n           \u2514\u2500\u2500 NodeExecutionContext H\n"})}),"\n",(0,i.jsx)(n.p,{children:"This hierarchy allows components to access data from their parent contexts, enabling data flow across the component\ntree."}),"\n",(0,i.jsx)(n.h2,{id:"executioncontext-class",children:"ExecutionContext Class"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ExecutionContext"})," is the base class for all context types:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class ExecutionContext:\n    executable_type: ExecutableTypeEnum\n    component_id: str\n    component_definition: Any\n    context_id: uuid.UUID\n    parent: Optional["ExecutionContext"]\n    execution_status: ExecutionStatusEnum\n    execution_results: dict[str, NodeExecutionResult]\n    run_context: RunContext\n'})}),"\n",(0,i.jsx)(n.h3,{id:"key-properties",children:"Key Properties"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"executable_type"}),": Type of the executable (agent, flow, node)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"component_id"}),": ID of the component being executed"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"parent"}),": Reference to the parent context (if any)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"execution_status"}),": Current status of execution"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"execution_results"}),": Dictionary mapping node IDs to execution results"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"run_context"}),": Reference to the global run context"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"component-communication-through-execution-context",children:"Component Communication through Execution Context"}),"\n",(0,i.jsxs)(n.p,{children:["One of the most powerful features of the Execution Context is enabling communication between components. This is done\nthrough referencing previous node results using the ",(0,i.jsx)(n.code,{children:"$hier{}"})," syntax in templates and expressions:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# In an AIModelNode prompt template\nprompt=Prompt.with_dad_text(\n    text=(\n        "## Repository Context\\n"\n        "$expr{$hier{dynamic_repo_analysis}.outcome.results}\\n\\n"\n        "## Previous Analysis\\n"\n        "$expr{$hier{code_generator}.outcome.structured.file_operations}"\n    ),\n)\n\n# In a FileOperationNode settings\noperations_template=ObjectTemplate(\n    expression="$expr{$hier{code_generator}.outcome.structured.file_operations}",\n)\n'})}),"\n",(0,i.jsx)(n.p,{children:"This pattern allows nodes to access outputs from previous executions and use them as inputs, creating a data flow\npipeline."}),"\n",(0,i.jsx)(n.h2,{id:"data-access",children:"Data Access"}),"\n",(0,i.jsx)(n.p,{children:"ExecutionContext provides methods for accessing data across the hierarchy:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Get a result from a specific node in the current context\nresult = execution_context.get_result("node_id")\n\n# Get a variable from the context hierarchy (local or from parent contexts)\nvalue = execution_context.get_context_variable("variable_name")\n\n# Get a reference to a node in the hierarchy by path\nnode_context = execution_context.get_context_by_path("flow1.node3")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"component-variables",children:"Component Variables"}),"\n",(0,i.jsx)(n.p,{children:"Component variables provide a way to share data across all nodes within a component:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Define variables at the flow level\nimplementation_flow = FlowDefinition()\nimplementation_flow.vars(\n    {\n        "task_spec": task_spec,  # This variable is accessible to all nodes in the flow\n    }\n)\n\n# Access component variables in node settings or templates\nprompt=Prompt.with_dad_text(\n    text=(\n        "Task Specification\\n"\n        "Task ID: $expr{task_spec.task_id}\\n"\n        "Description: $expr{task_spec.description}\\n\\n"\n    ),\n)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Component variables improve code organization by centralizing configuration and enabling reusability."}),"\n",(0,i.jsx)(n.h2,{id:"hierarchical-references",children:"Hierarchical References"}),"\n",(0,i.jsx)(n.p,{children:"One of the most powerful features of the execution context is the ability to reference results from other nodes using\nhierarchical paths:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# In a template or expression\n"$hier{flow_id.node_id.outcome.structured.property}"\n'})}),"\n",(0,i.jsx)(n.p,{children:"This allows data to flow naturally between components without having to manually pass results around."}),"\n",(0,i.jsx)(n.h2,{id:"template-expressions",children:"Template Expressions"}),"\n",(0,i.jsx)(n.p,{children:"The Execution Context integrates with the template system to allow dynamic content based on context variables and node\nresults:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Basic variable substitution\n"$var{task_description}"\n\n# Expression evaluation\n"$expr{task_spec.required_context}"\n\n# Hierarchical reference to previous node result\n"$expr{$hier{dynamic_repo_analysis}.outcome.results}"\n\n# Combining multiple references\n"$expr{$hier{code_generator}.outcome.structured.file_operations[$var{index}]}"\n'})}),"\n",(0,i.jsx)(n.p,{children:"The template engine resolves these expressions at runtime using the current execution context."}),"\n",(0,i.jsx)(n.h2,{id:"result-management",children:"Result Management"}),"\n",(0,i.jsx)(n.p,{children:"Results from node executions are stored in the context:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Store a result\nexecution_context.set_result("node_id", node_execution_result)\n\n# Retrieve a result\nresult = execution_context.get_result("node_id")\n\n# Check if a result exists\nhas_result = execution_context.has_result("node_id")\n'})}),"\n",(0,i.jsx)(n.h2,{id:"integration-with-template-engine",children:"Integration with Template Engine"}),"\n",(0,i.jsx)(n.p,{children:"The Execution Context integrates deeply with the templating system, enabling dynamic content generation based on\nexecution results:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Render a template with context variables\nresult = TemplateEngine.render_template(\n    template="Value from previous node: $hier{node_id.outcome.text}",\n    variables={},\n    execution_context=execution_context\n)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"creating-and-using-execution-contexts",children:"Creating and Using Execution Contexts"}),"\n",(0,i.jsx)(n.p,{children:"Contexts are typically created when executing components:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Create a context for a flow\nflow_context = FlowExecutionContext(\n    component_id="my_flow",\n    component_definition=my_flow_definition,\n    parent=parent_context,  # Optional\n    run_context=run_context\n)\n\n# Execute a component with the context\nresult = await my_flow.execute(flow_context)\n'})}),"\n",(0,i.jsx)(n.h2,{id:"practical-example",children:"Practical Example"}),"\n",(0,i.jsx)(n.p,{children:"Here's a practical example showing how Execution Context enables data flow in a multi-node workflow:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Folder analysis node that analyzes files\nimplementation_flow.node(\n    "dynamic_repo_analysis",\n    FolderAnalyzerNode(\n        settings=FolderAnalyzerSettings(\n            base_directory=global_data_directory,\n            operations=folder_operations,\n        ),\n    ),\n)\n\n# Code generation node that uses the analysis results\nimplementation_flow.node(\n    "code_generator",\n    AIModelNode(\n        settings=AIModelNodeSettings(\n            prompt=Prompt.with_dad_text(\n                text=(\n                    "## Repository Context\\n"\n                    "$expr{$hier{dynamic_repo_analysis}.outcome.results}\\n\\n"\n                ),\n            ),\n            model_call_config=AIModelCallConfig(\n                structured_output=TaskImplementation,\n            ),\n        ),\n    ),\n)\n\n# File operation node that uses the generated code operations\nimplementation_flow.node(\n    "code_generator_file_ops",\n    FileOperationNode(\n        settings=FileOperationNodeSettings(\n            base_directory=global_data_directory,\n            operations_template=ObjectTemplate(\n                expression="$expr{$hier{code_generator}.outcome.structured.file_operations}",\n            ),\n            stage=True,\n        ),\n    ),\n)\n'})}),"\n",(0,i.jsx)(n.p,{children:"This pattern demonstrates how data flows between nodes through the Execution Context without requiring direct\nconnections."}),"\n",(0,i.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Respect Scoping Rules"}),": Access only results that are in scope for your component"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Hierarchical References"}),": Leverage ",(0,i.jsx)(n.code,{children:"$hier{}"})," syntax for cross-component references"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Keep Contexts Clean"}),": Avoid storing excessive data in context variables"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cache Results When Appropriate"}),": For expensive operations, cache results in the context"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Be Careful with Circular References"}),": Avoid creating circular dependencies in hierarchical references"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Use Component Variables"}),": Use flow-level variables for configuration that needs to be shared across nodes"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prefer Explicit References"}),": Be explicit in your references to make the data flow clear"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"The Execution Context system in DAD provides a powerful mechanism for managing state, sharing data between components,\nand coordinating complex workflows. By understanding and effectively using the execution context, you can create\nsophisticated agent behaviors with clean, well-structured data flows."})]})}function x(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>c});var o=t(6540);const i={},s=o.createContext(i);function r(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);