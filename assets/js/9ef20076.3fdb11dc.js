"use strict";(self.webpackChunkdhenara_docs=self.webpackChunkdhenara_docs||[]).push([[9214],{6656:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"dhenara-agent/components/flows","title":"Flows","description":"Overview","source":"@site/docs/dhenara-agent/components/flows.md","sourceDirName":"dhenara-agent/components","slug":"/dhenara-agent/components/flows","permalink":"/dhenara-agent/components/flows","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Flows"},"sidebar":"dhenaraAgentSidebar","previous":{"title":"Agents","permalink":"/dhenara-agent/components/agents"},"next":{"title":"Nodes","permalink":"/dhenara-agent/components/nodes"}}');var t=o(4848),i=o(8453);const l={title:"Flows"},c="Flows",r={},a=[{value:"Overview",id:"overview",level:2},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Creating Flows",id:"creating-flows",level:2},{value:"Adding Nodes to Flows",id:"adding-nodes-to-flows",level:2},{value:"Flow Execution Patterns",id:"flow-execution-patterns",level:2},{value:"Sequential Execution",id:"sequential-execution",level:3},{value:"Conditional Execution",id:"conditional-execution",level:3},{value:"Loop Execution",id:"loop-execution",level:3},{value:"Custom Node Connections",id:"custom-node-connections",level:2},{value:"Working with Subflows",id:"working-with-subflows",level:2},{value:"Accessing Flow Results",id:"accessing-flow-results",level:2},{value:"Flow Execution Context",id:"flow-execution-context",level:2},{value:"Common Flow Patterns",id:"common-flow-patterns",level:2},{value:"Data Processing Flow",id:"data-processing-flow",level:3},{value:"Decision-Making Flow",id:"decision-making-flow",level:3},{value:"Iterative Processing Flow",id:"iterative-processing-flow",level:3},{value:"Best Practices",id:"best-practices",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"flows",children:"Flows"})}),"\n",(0,t.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(n.p,{children:"Flows in Dhenara Agent DSL (DAD) are intermediate components that organize nodes into connected processing pipelines.\nThey define the execution logic, including sequential processing, conditionals, and loops. Flows serve as the primary\nway to orchestrate the execution of nodes to achieve specific goals."}),"\n",(0,t.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,t.jsx)(n.p,{children:"Flows in DAD are built around these key concepts:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nodes as Building Blocks"}),": Flows connect and coordinate nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Execution Logic"}),": Flows define how and when nodes are executed"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Data Flow"}),": Flows manage how data moves between nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reusability"}),": Flows can be composed and reused in different contexts"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nesting"}),": Flows can contain other flows (subflows) for modular design"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"creating-flows",children:"Creating Flows"}),"\n",(0,t.jsxs)(n.p,{children:["Flows are created using the ",(0,t.jsx)(n.code,{children:"FlowDefinition"})," class:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from dhenara.agent.dsl import FlowDefinition\n\n# Create a flow definition\nmy_flow = FlowDefinition(root_id="my_flow")\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The optional ",(0,t.jsx)(n.code,{children:"root_id"})," parameter sets a unique identifier for the flow, which is useful when referencing the flow from\nother components."]}),"\n",(0,t.jsx)(n.h2,{id:"adding-nodes-to-flows",children:"Adding Nodes to Flows"}),"\n",(0,t.jsxs)(n.p,{children:["Nodes are added to flows using the ",(0,t.jsx)(n.code,{children:"node"})," method:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Add nodes to the flow\nmy_flow.node("analyzer", analyzer_node)\nmy_flow.node("processor", processor_node)\nmy_flow.node("output", output_node)\n'})}),"\n",(0,t.jsx)(n.p,{children:"Each node is assigned a unique ID within the flow, which can be used to reference the node from other parts of the flow\nor from other components."}),"\n",(0,t.jsx)(n.h2,{id:"flow-execution-patterns",children:"Flow Execution Patterns"}),"\n",(0,t.jsx)(n.p,{children:"DAD supports several execution patterns for flows:"}),"\n",(0,t.jsx)(n.h3,{id:"sequential-execution",children:"Sequential Execution"}),"\n",(0,t.jsx)(n.p,{children:"By default, nodes in a flow are executed sequentially, with each node running after the previous one completes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Create a sequential flow\nsequential_flow = FlowDefinition()\nsequential_flow.node("step1", step1_node)\nsequential_flow.node("step2", step2_node)\nsequential_flow.node("step3", step3_node)\n\n# Explicitly define sequence\nsequential_flow.sequence(["step1", "step2", "step3"])\n'})}),"\n",(0,t.jsx)(n.h3,{id:"conditional-execution",children:"Conditional Execution"}),"\n",(0,t.jsx)(n.p,{children:"Conditional execution allows for different execution paths based on conditions:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Create true and false branch flows\ntrue_branch = FlowDefinition()\ntrue_branch.node("success_action", success_node)\n\nfalse_branch = FlowDefinition()\nfalse_branch.node("fallback_action", fallback_node)\n\n# Add conditional to the main flow\nmain_flow = FlowDefinition()\nmain_flow.node("data_analyzer", analyzer_node)\nmain_flow.conditional(\n    "condition_check",\n    statement=ObjectTemplate(expression="$hier{data_analyzer}.outcome.structured.success == True"),\n    true_branch=true_branch,\n    false_branch=false_branch\n)\n'})}),"\n",(0,t.jsx)(n.p,{children:"The condition is evaluated using the template engine, which can access results from previous nodes using hierarchical\nreferences."}),"\n",(0,t.jsx)(n.h3,{id:"loop-execution",children:"Loop Execution"}),"\n",(0,t.jsx)(n.p,{children:"Loops allow for iterative processing over collections of items:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Create a loop body flow\nloop_body = FlowDefinition()\nloop_body.node("process_item", process_node)\n\n# Add loop to the main flow\nmain_flow = FlowDefinition()\nmain_flow.node("data_collector", collector_node)\nmain_flow.for_each(\n    "process_items",\n    statement=ObjectTemplate(expression="$hier{data_collector}.outcome.structured.items"),\n    body=loop_body,\n    max_iterations=100,\n    item_var="current_item",\n    index_var="item_index"\n)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The loop iterates over each item in the collection, with each item accessible via the ",(0,t.jsx)(n.code,{children:"item_var"})," in the loop body."]}),"\n",(0,t.jsx)(n.h2,{id:"custom-node-connections",children:"Custom Node Connections"}),"\n",(0,t.jsx)(n.p,{children:"While the default patterns cover most use cases, you can also create custom connections between nodes:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Create a flow with custom connections\ncustom_flow = FlowDefinition()\ncustom_flow.node("start", start_node)\ncustom_flow.node("process_a", process_a_node)\ncustom_flow.node("process_b", process_b_node)\ncustom_flow.node("end", end_node)\n\n# Connect nodes with custom logic\ncustom_flow.connect("start", "process_a", on_success=True)\ncustom_flow.connect("start", "process_b", on_error=True)\ncustom_flow.connect("process_a", "end", on_success=True)\ncustom_flow.connect("process_b", "end", on_success=True)\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This example creates a flow where ",(0,t.jsx)(n.code,{children:"process_a"})," is executed if ",(0,t.jsx)(n.code,{children:"start"})," succeeds, and ",(0,t.jsx)(n.code,{children:"process_b"})," is executed if ",(0,t.jsx)(n.code,{children:"start"}),"\nfails. Both processing paths then connect to the ",(0,t.jsx)(n.code,{children:"end"})," node."]}),"\n",(0,t.jsx)(n.h2,{id:"working-with-subflows",children:"Working with Subflows"}),"\n",(0,t.jsx)(n.p,{children:"Flows can include other flows as subflows, enabling modular design:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Create a subflow\nsubflow = FlowDefinition()\nsubflow.node("subflow_node_1", subflow_node_1)\nsubflow.node("subflow_node_2", subflow_node_2)\n\n# Add the subflow to a main flow\nmain_flow = FlowDefinition()\nmain_flow.node("main_node_1", main_node_1)\nmain_flow.subflow("processing_subflow", subflow)\nmain_flow.node("main_node_2", main_node_2)\n'})}),"\n",(0,t.jsx)(n.p,{children:"Subflows are executed as part of the parent flow, and their results are accessible using hierarchical references."}),"\n",(0,t.jsx)(n.h2,{id:"accessing-flow-results",children:"Accessing Flow Results"}),"\n",(0,t.jsx)(n.p,{children:"Results from nodes in a flow can be accessed using hierarchical references:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Access a node result within the same flow\n"$hier{node_id}.outcome.text"\n\n# Access a node result from a specific flow\n"$hier{flow_id.node_id}.outcome.structured.property"\n\n# Access a node result from a subflow\n"$hier{flow_id.subflow_id.node_id}.outcome.structured.property"\n'})}),"\n",(0,t.jsx)(n.p,{children:"These references can be used in templates to dynamically generate content based on previous results."}),"\n",(0,t.jsx)(n.h2,{id:"flow-execution-context",children:"Flow Execution Context"}),"\n",(0,t.jsxs)(n.p,{children:["When a flow is executed, it creates a ",(0,t.jsx)(n.code,{children:"FlowExecutionContext"})," that manages the flow's state and results:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Execute a flow with a specific context\nresult = await flow.execute(\n    execution_context=FlowExecutionContext(\n        component_id="my_flow",\n        component_definition=flow,\n        run_context=run_context\n    )\n)\n'})}),"\n",(0,t.jsx)(n.p,{children:"The execution context keeps track of all node results and provides access to them throughout execution."}),"\n",(0,t.jsx)(n.h2,{id:"common-flow-patterns",children:"Common Flow Patterns"}),"\n",(0,t.jsx)(n.h3,{id:"data-processing-flow",children:"Data Processing Flow"}),"\n",(0,t.jsx)(n.p,{children:"A common pattern is to create a flow that processes data in stages:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Create a data processing flow\nprocessing_flow = FlowDefinition()\nprocessing_flow.node("data_collector", collector_node)\nprocessing_flow.node("data_analyzer", analyzer_node)\nprocessing_flow.node("data_transformer", transformer_node)\nprocessing_flow.node("data_exporter", exporter_node)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"decision-making-flow",children:"Decision-Making Flow"}),"\n",(0,t.jsx)(n.p,{children:"Another common pattern is a flow that makes decisions based on analysis:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Create a decision-making flow\ndecision_flow = FlowDefinition()\ndecision_flow.node("data_analyzer", analyzer_node)\ndecision_flow.conditional(\n    "decision_point",\n    statement=ObjectTemplate(expression="$hier{data_analyzer}.outcome.structured.score > 0.7"),\n    true_branch=high_score_flow,\n    false_branch=low_score_flow\n)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"iterative-processing-flow",children:"Iterative Processing Flow"}),"\n",(0,t.jsx)(n.p,{children:"Iterative processing flows handle collections of items:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'# Create an iterative processing flow\niterative_flow = FlowDefinition()\niterative_flow.node("data_collector", collector_node)\niterative_flow.for_each(\n    "item_processor",\n    statement=ObjectTemplate(expression="$hier{data_collector}.outcome.structured.items"),\n    body=item_processor_flow\n)\niterative_flow.node("result_aggregator", aggregator_node)\n'})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Logical Organization"}),": Organize flows to represent clear logical steps"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Modular Design"}),": Use subflows to create reusable components"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Clear Naming"}),": Use descriptive names for flows and nodes"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Error Handling"}),": Include conditional branches for handling errors"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Documentation"}),": Document the purpose and behavior of each flow"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By following these practices, you can create clear, maintainable flows that effectively orchestrate complex processing\ntasks."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>l,x:()=>c});var s=o(6540);const t={},i=s.createContext(t);function l(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);