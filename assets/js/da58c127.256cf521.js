"use strict";(self.webpackChunkdhenara_docs=self.webpackChunkdhenara_docs||[]).push([[6516],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var o=t(6540);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}},9852:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"dhenara-agent/concepts/components/custom-components","title":"Custom Components","description":"Overview","source":"@site/docs/dhenara-agent/concepts/components/custom-components.md","sourceDirName":"dhenara-agent/concepts/components","slug":"/dhenara-agent/concepts/components/custom-components","permalink":"/dhenara-agent/concepts/components/custom-components","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Custom Components"},"sidebar":"dhenaraAgentSidebar","previous":{"title":"Agents","permalink":"/dhenara-agent/concepts/components/agents"},"next":{"title":"Templating System","permalink":"/dhenara-agent/concepts/templating-system"}}');var s=t(4848),r=t(8453);const a={title:"Custom Components"},i="Custom Components",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Why Create Custom Components",id:"why-create-custom-components",level:2},{value:"Types of Custom Components",id:"types-of-custom-components",level:2},{value:"Custom Nodes",id:"custom-nodes",level:3},{value:"Custom Flows",id:"custom-flows",level:3},{value:"Custom Agents",id:"custom-agents",level:3},{value:"Creating Custom Nodes",id:"creating-custom-nodes",level:2},{value:"1. Node Settings Class",id:"1-node-settings-class",level:3},{value:"2. Node Input/Output Classes",id:"2-node-inputoutput-classes",level:3},{value:"3. Node Definition Class",id:"3-node-definition-class",level:3},{value:"4. Node Executor",id:"4-node-executor",level:3},{value:"5. Register the Node Type",id:"5-register-the-node-type",level:3},{value:"Using Custom Nodes",id:"using-custom-nodes",level:2},{value:"Creating Custom Flow Patterns",id:"creating-custom-flow-patterns",level:2},{value:"Creating Custom Agent Patterns",id:"creating-custom-agent-patterns",level:2},{value:"Best Practices for Custom Components",id:"best-practices-for-custom-components",level:2},{value:"Advanced Extensions",id:"advanced-extensions",level:2},{value:"Custom Template Functions",id:"custom-template-functions",level:3},{value:"Custom Event Types",id:"custom-event-types",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"custom-components",children:"Custom Components"})}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"Dhenara Agent DSL (DAD) is designed to be extensible, allowing you to create custom components that address specific\nneeds beyond what's provided by the built-in components. This extensibility enables you to tailor DAD to your unique use\ncases while maintaining the benefits of the framework's architecture and execution model."}),"\n",(0,s.jsx)(n.h2,{id:"why-create-custom-components",children:"Why Create Custom Components"}),"\n",(0,s.jsx)(n.p,{children:"There are several reasons to create custom components:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Domain-Specific Functionality"}),": Implement components that understand your specific domain"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Integration with External Systems"}),": Create nodes that interact with your existing systems"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Specialized Processing"}),": Implement optimized components for specific types of data processing"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Unique Workflows"}),": Define custom flow patterns that match your organization's processes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enhanced Capabilities"}),": Add new capabilities to the DAD ecosystem"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"types-of-custom-components",children:"Types of Custom Components"}),"\n",(0,s.jsx)(n.p,{children:"You can extend DAD at multiple levels:"}),"\n",(0,s.jsx)(n.h3,{id:"custom-nodes",children:"Custom Nodes"}),"\n",(0,s.jsx)(n.p,{children:"Custom nodes are the most common extension point, allowing you to implement new atomic operations."}),"\n",(0,s.jsx)(n.h3,{id:"custom-flows",children:"Custom Flows"}),"\n",(0,s.jsx)(n.p,{children:"Custom flows enable you to create reusable flow patterns with specialized logic."}),"\n",(0,s.jsx)(n.h3,{id:"custom-agents",children:"Custom Agents"}),"\n",(0,s.jsx)(n.p,{children:"Custom agents can implement specialized coordination patterns for complex workflows."}),"\n",(0,s.jsx)(n.h2,{id:"creating-custom-nodes",children:"Creating Custom Nodes"}),"\n",(0,s.jsx)(n.p,{children:"To create a custom node, you need to define several components:"}),"\n",(0,s.jsx)(n.h3,{id:"1-node-settings-class",children:"1. Node Settings Class"}),"\n",(0,s.jsxs)(n.p,{children:["Define a settings class that inherits from ",(0,s.jsx)(n.code,{children:"NodeSettings"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from dhenara.agent.dsl.base import NodeSettings\nfrom pydantic import Field\n\nclass DatabaseQueryNodeSettings(NodeSettings):\n    connection_string: str\n    query_template: str\n    timeout: int = Field(default=30, description="Query timeout in seconds")\n    max_rows: int = Field(default=1000, description="Maximum rows to return")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-node-inputoutput-classes",children:"2. Node Input/Output Classes"}),"\n",(0,s.jsx)(n.p,{children:"Define input and output classes for your node:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from dhenara.agent.dsl.base import NodeInput, NodeOutput\nfrom typing import Any, Dict, List\n\nclass DatabaseQueryNodeInput(NodeInput):\n    query_parameters: Dict[str, Any] = Field(default_factory=dict)\n    settings_override: DatabaseQueryNodeSettings | None = None\n\nclass DatabaseQueryNodeOutput(NodeOutput):\n    rows: List[Dict[str, Any]]\n    row_count: int\n    execution_time: float\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-node-definition-class",children:"3. Node Definition Class"}),"\n",(0,s.jsxs)(n.p,{children:["Create a node definition class that inherits from ",(0,s.jsx)(n.code,{children:"NodeDefinition"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from dhenara.agent.dsl.base import NodeDefinition\n\nclass DatabaseQueryNode(NodeDefinition):\n    node_type: str = "database_query"  # Unique identifier for this node type\n    settings: DatabaseQueryNodeSettings | None = None\n\n    def __init__(self,\n                settings: DatabaseQueryNodeSettings | None = None,\n                pre_events: list[str] | None = None,\n                post_events: list[str] | None = None):\n        super().__init__(settings=settings, pre_events=pre_events, post_events=post_events)\n'})}),"\n",(0,s.jsx)(n.h3,{id:"4-node-executor",children:"4. Node Executor"}),"\n",(0,s.jsx)(n.p,{children:"Implement a node executor that performs the actual work:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from dhenara.agent.dsl.base import NodeExecutor\nimport asyncio\nimport time\nimport aiosqlite  # Or any async database library\n\nclass DatabaseQueryNodeExecutor(NodeExecutor):\n    async def execute(self,\n                     node_id: str,\n                     execution_context: ExecutionContext,\n                     node_input: DatabaseQueryNodeInput | None = None) -> NodeExecutionResult:\n        # Get settings, merging with overrides if provided\n        settings = self.get_settings(execution_context, node_input)\n\n        # Prepare the query with parameters\n        query = self.prepare_query(settings.query_template, node_input.query_parameters)\n\n        # Execute the query\n        start_time = time.time()\n        try:\n            async with aiosqlite.connect(settings.connection_string) as db:\n                db.row_factory = lambda cursor, row: {col[0]: row[idx] for idx, col in enumerate(cursor.description)}\n                async with db.execute(query) as cursor:\n                    rows = await cursor.fetchmany(settings.max_rows)\n                    row_count = len(rows)\n        except Exception as e:\n            return NodeExecutionResult.failure(f"Database query failed: {str(e)}")\n\n        execution_time = time.time() - start_time\n\n        # Create output\n        output = DatabaseQueryNodeOutput(\n            rows=rows,\n            row_count=row_count,\n            execution_time=execution_time\n        )\n\n        # Create outcome for easy access\n        outcome = NodeOutcome(\n            structured={\n                "rows": rows,\n                "row_count": row_count,\n                "execution_time": execution_time\n            }\n        )\n\n        return NodeExecutionResult.success(output, outcome)\n\n    def prepare_query(self, query_template: str, parameters: Dict[str, Any]) -> str:\n        # Simple parameter replacement - in practice, use proper SQL parameter binding\n        result = query_template\n        for key, value in parameters.items():\n            result = result.replace(f"${key}", str(value))\n        return result\n'})}),"\n",(0,s.jsx)(n.h3,{id:"5-register-the-node-type",children:"5. Register the Node Type"}),"\n",(0,s.jsx)(n.p,{children:"Register your custom node type with the node executor registry:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from dhenara.agent.dsl.registry import node_executor_registry\n\n# Register the executor for the node type\nnode_executor_registry.register("database_query", DatabaseQueryNodeExecutor)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"using-custom-nodes",children:"Using Custom Nodes"}),"\n",(0,s.jsx)(n.p,{children:"Once registered, you can use your custom node like any built-in node:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'# Create a flow with the custom node\ndata_flow = FlowDefinition()\ndata_flow.node(\n    "user_query",\n    DatabaseQueryNode(\n        settings=DatabaseQueryNodeSettings(\n            connection_string="sqlite:///my_database.db",\n            query_template="SELECT * FROM users WHERE age > $min_age LIMIT $limit",\n            timeout=60,\n            max_rows=500\n        ),\n        pre_events=[EventType.node_input_required]\n    )\n)\ndata_flow.node("result_processor", result_processor_node)\n\n# Create an input handler for the custom node\nasync def handle_database_input(event: NodeInputRequiredEvent):\n    if event.node_id == "user_query":\n        event.input = DatabaseQueryNodeInput(\n            query_parameters={\n                "min_age": 25,\n                "limit": 100\n            }\n        )\n        event.handled = True\n\n# Register the handler\nrun_context.register_node_input_handler(handle_database_input)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"creating-custom-flow-patterns",children:"Creating Custom Flow Patterns"}),"\n",(0,s.jsx)(n.p,{children:"You can create reusable flow patterns by defining factory functions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def create_data_processing_flow(data_source: str, processing_type: str) -> FlowDefinition:\n    """Create a standardized data processing flow."""\n    flow = FlowDefinition()\n\n    # Add data source node based on source type\n    if data_source == "database":\n        flow.node("data_source", DatabaseQueryNode(...))\n    elif data_source == "api":\n        flow.node("data_source", APIRequestNode(...))\n    elif data_source == "file":\n        flow.node("data_source", FileReaderNode(...))\n\n    # Add processing nodes based on processing type\n    if processing_type == "transform":\n        flow.node("processor", DataTransformNode(...))\n    elif processing_type == "filter":\n        flow.node("processor", DataFilterNode(...))\n    elif processing_type == "aggregate":\n        flow.node("processor", DataAggregationNode(...))\n\n    # Common result handling\n    flow.node("result_formatter", ResultFormatterNode(...))\n\n    return flow\n\n# Use the factory function\ndb_transform_flow = create_data_processing_flow("database", "transform")\napi_filter_flow = create_data_processing_flow("api", "filter")\n'})}),"\n",(0,s.jsx)(n.h2,{id:"creating-custom-agent-patterns",children:"Creating Custom Agent Patterns"}),"\n",(0,s.jsx)(n.p,{children:"Similarly, you can create factory functions for specialized agent patterns:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def create_etl_agent(source_config: dict, transform_config: dict, load_config: dict) -> AgentDefinition:\n    """Create an ETL (Extract, Transform, Load) agent."""\n    agent = AgentDefinition()\n\n    # Create extraction flow\n    extract_flow = create_extraction_flow(source_config)\n    agent.flow("extract", extract_flow)\n\n    # Create transformation flow\n    transform_flow = create_transformation_flow(transform_config)\n    agent.flow("transform", transform_flow)\n\n    # Create loading flow\n    load_flow = create_loading_flow(load_config)\n    agent.flow("load", load_flow)\n\n    # Sequence the flows\n    agent.sequence(["extract", "transform", "load"])\n\n    return agent\n\n# Use the factory function\netl_agent = create_etl_agent(\n    source_config={"type": "postgres", "connection_string": "..."},\n    transform_config={"operations": ["clean", "normalize", "enrich"]},\n    load_config={"destination": "data_warehouse", "mode": "incremental"}\n)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-custom-components",children:"Best Practices for Custom Components"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Follow the Single Responsibility Principle"}),": Each component should do one thing well"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Document Thoroughly"}),": Provide clear documentation for your custom components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Ensure Type Safety"}),": Use Pydantic models to ensure type safety and validation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle Errors Gracefully"}),": Implement proper error handling in custom executors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Write Tests"}),": Create tests to verify the behavior of your custom components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Consider Reusability"}),": Design components to be reusable across different contexts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Respect the DAD Component Model"}),": Follow the same patterns as built-in components"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"advanced-extensions",children:"Advanced Extensions"}),"\n",(0,s.jsx)(n.p,{children:"For advanced use cases, you can extend deeper parts of the DAD framework:"}),"\n",(0,s.jsx)(n.h3,{id:"custom-template-functions",children:"Custom Template Functions"}),"\n",(0,s.jsx)(n.p,{children:"Extend the template engine with custom functions:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from dhenara.agent.dsl.templates import DADTemplateEngine\n\n# Register a custom function\nDADTemplateEngine.register_function(\n    "encrypt",\n    lambda text, key: some_encryption_function(text, key)\n)\n\n# Use in templates\n"Encrypted value: $expr{encrypt(value, \'my-key\')}"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"custom-event-types",children:"Custom Event Types"}),"\n",(0,s.jsx)(n.p,{children:"Define custom event types for specialized communication:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from dhenara.agent.dsl.events import BaseEvent, EventType\n\n# Define a custom event type\nEventType.custom_approval_required = "custom_approval_required"\n\n# Define the event class\nclass ApprovalRequiredEvent(BaseEvent):\n    event_type: str = EventType.custom_approval_required\n    approver: str\n    request_details: dict\n    approval_status: bool | None = None\n    notes: str | None = None\n\n# Register a handler\nasync def handle_approval(event: ApprovalRequiredEvent):\n    # Get approval through UI or API\n    approval_result = await get_approval_from_user(event.approver, event.request_details)\n    event.approval_status = approval_result.status\n    event.notes = approval_result.notes\n    event.handled = True\n\n# Register the handler\nevent_bus.register(EventType.custom_approval_required, handle_approval)\n'})}),"\n",(0,s.jsx)(n.p,{children:"By extending DAD with custom components, you can adapt the framework to your specific needs while maintaining the\nbenefits of its architecture and execution model."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}}}]);